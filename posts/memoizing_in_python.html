<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
        <title>wmasson - Memoizing Functions in Python</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css"></link>
	<link rel="stylesheet" type="text/css" href="../css/syntax.css"></link>
        <link rel="alternate" type="application/rss+xml" title="Blog" href="../rss.xml"></link>
    </head>
    <body>
        <h1><div id="title"><span class="rounded">wmasson</span></div></h1>
        <div id="navigation">
            <p><a href="../" class="rounded">Home</a></p>
            <p><a href="../posts.html" class="rounded">Posts</a></p>
	    <p><a href="../tags.html" class="rounded">Tags</a></p>
            <p><a href="../about.html" class="rounded">About</a></p>
	    <p><a href="../rss.xml" class="rounded">RSS</a></p>
        </div>
        <div id="content"><h2>Memoizing Functions in Python</h2>

<p>On <strong>January  6, 2013</strong></p>

<p>Memoization is the process of storing the return values of a function so that if the function is called again with the same arguments, we can return the stored value instead of recomputing it. Suppose we have a function f that is costly to run. We can memoize the return values by calling an intermediary</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> f(x):
	<span class="co"># some expensive computation</span>

seen = {} 

<span class="kw">def</span> memoize_f(x):
	<span class="kw">if</span> x in seen:
		<span class="kw">return</span> seen[x]
	<span class="kw">else</span>:
		seen[x] = f(x)
		<span class="kw">return</span> seen[x]</code></pre>
<p>If we want to call f, instead we call memoize_f and it will remember the values. This is inconvenient for two reasons. If we have another function, say g, that needs to be memoized we need another function memoize_g. Also, the seen list is globally accessable which is undesirable. Instead a class can be made to wrap the function and handle these things.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> memoizer:
	<span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,f):
		<span class="ot">self</span>.seen = {}
		<span class="ot">self</span>.f = f

	<span class="kw">def</span> lookup(<span class="ot">self</span>,x):
		<span class="kw">if</span> x in <span class="ot">self</span>.seen:
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]
		<span class="kw">else</span>:
			<span class="ot">self</span>.seen[x] = <span class="ot">self</span>.f(x)
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]

memoize_f = memoizer(f)</code></pre>
<p>This is a cleaner solution. When we want to get the value of f(x) we can call memoize_f.lookup(x). This is somewhat inelegent, ideally we should just have memoize_f be a function itself.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> memoize_func(f):
	m = memoizer(f)
	<span class="kw">return</span> m.lookup

memoize_f = memoize_func(f)</code></pre>
<p>This will return the part we want - the lookup function. This has the added bonus of obscuring the class itself: instead we just have the function that acts like f and we don’t have to worry about how the memoization works. There’s another little trick to make this even better.</p>
<pre><code>memoize = memoize_func(memoize_func)</code></pre>
<p>Here we have memoized the memoize_func so we always get back the same memoized version of a function. Suppose we want the memoized version of f but don’t have it in scope, then if we can just call memoize(f) and get the same memoized version we had before. For one final addition, let’s make it support multiple arguments:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> memoizer:	
	<span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,f):
		<span class="ot">self</span>.seen = {}
		<span class="ot">self</span>.f = f

	<span class="kw">def</span> lookup(<span class="ot">self</span>,*x):
		<span class="kw">if</span> x in <span class="ot">self</span>.seen:
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]
		<span class="kw">else</span>:
			<span class="ot">self</span>.seen[x] = <span class="ot">self</span>.f(*x)
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]</code></pre>
<p>This uses python’s *args feature to get a list of arguments.</p>

<p>Tags: <a href="../tags/python.html">python</a>, <a href="../tags/functional programming.html">functional programming</a>.</p>

</div>
        <div id="footer">
            <p>This site generated using <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            Background by <a href="http://subtlepatterns.com/cubes">Sander Ottens</a>.</p>
        </div>
    </body>
    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37381827-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</html>
