<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>A simple introduction to Lambda Calculus</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/rss+xml" title="Blog" href="../rss.xml" />
    </head>
    <body>
        <div id="header">
        <img src="../images/header.jpg" alt="header" />
        </div>

        <div id="navigation">
            <p><h2 class="rounded">Warwick Masson</h2></p>
            <p><a href="../" class="rounded">Home</a></p>
            <p><a href="../posts.html" class="rounded">Posts</a></p>
	    <p><a href="../tags.html" class="rounded">Tags</a></p>
            <p><a href="../about.html" class="rounded">About</a></p>
	    <p><a href="../rss.xml" class="rounded">RSS</a></p>
        </div>
        <div id="content"><h2>A simple introduction to Lambda Calculus</h2>

<p>On <strong>August  3, 2013</strong></p>

<p>The idea behind the lambda calculus is to develop a complete model of computation from lambda functions. Lambda functions are anonymous functions that can construct other functions.</p>
<h4 id="scheme-syntax">Scheme Syntax</h4>
<p>For this post I’ll be using scheme syntax, so</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(f x)</code></pre>
<p>Denotes the application of function f to x, i.e. f(x). In scheme, define binds a new variable with a particular value. For example,</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> x </span><span class="dv">2</span>)</code></pre>
<p>Defines x to be 2.</p>
<p>In functional languages we can use functions as parameters. This allows for greater flexibility in what functions can do.</p>
<h4 id="lambda-functions">Lambda Functions</h4>
<p>A lambda function is an anonymous function. In scheme and other lisps, we define a lambda function in the following way:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (arg1 arg2 ... argn) (f arg1 arg2 ... argn))</code></pre>
<p>defines a function with parameters arg1, arg2, …, argn and returns (f arg1 arg2 … argn). For example, the function</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (x) x)</code></pre>
<p>is the identity function - it takes a parameter x and returns it as is. As we can take other functions as parameters, we can build up as complex expressions as desired. We can for example return other lambda functions:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (x) (<span class="kw">lambda</span> (y) (<span class="kw">+</span> x y)))</code></pre>
<p>is a function which takes a parameter x, and returns a function which adds x to its value.</p>
<h4 id="boolean-algebra">Boolean Algebra</h4>
<p>We can implement boolean algebra within the lambda calculus with the following functions. First off, we need to represent true and false.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> true</span>
    (<span class="kw">lambda</span> (a b) a))

(<span class="kw">define</span><span class="fu"> false</span>
    <span class="kw">lambda</span> (a b) b))</code></pre>
<p>So true is a function that returns the first of its arguments. Similarly, false is a function that returns the second of its arguments. We’ll see why we’ve defined it this way in a moment.</p>
<p>Now, let’s define the logical connectives.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> or</span>
    (<span class="kw">lambda</span> (a b) (a a b)))

(<span class="kw">define</span><span class="fu"> and</span>
    (<span class="kw">lambda</span> (a b) (a b a)))</code></pre>
<p>To understand these, just focus on how they interact with our lambda true and false. If we call (or a b), there are two possible cases. The call itself expands to (a a b). If a is true, the call is (true true b) - by our definition of true, it’ll return true. If a is false, the call is (false a b) - so this returns the second argument which is b.</p>
<p>Now, let’s look at and. The call (and a b) expands to (a b a). If a is true, the function returns b. Otherwise, it returns a which is false.</p>
<p>Both of these satisfy our standard definitions of and and or. Now, let’s look at not.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> not</span>
    (<span class="kw">lambda</span> (a)
        (<span class="kw">lambda</span> (b c)
            (a c b))))</code></pre>
<p>The not definition looks complex but it’s actually simple. All not does is defines a wrapper around the true or false that swaps the arguments around. As the definition of true and false are the same except the arguments to them with their values swapped, this inverts the values.</p>
<p>Now, let’s implement a basic if function. We want such that (if condition exp1 exp2) will return exp1 if condition is true, exp2 otherwise. Our definition of if is as follows:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> if</span>
    (<span class="kw">lambda</span> (condition exp1 exp2)
        (condition exp1 exp2)))</code></pre>
<p>It’s simple really, all it does is use the condition to select the correct expression.</p>
<h4 id="pairs">Pairs</h4>
<p>The pair is the fundamental data-type used in scheme and other lisps. A lambda pair is an ordered pair of two values. So (pair 1 2) gives you (1 2). To get the items back out, we use the head and tail functions. (head (pair x y)) returns x. The tail function accesses the other value, so (tail (pair x y)) returns y.</p>
<p>The reason the pair is important is that we can pair together existing pairs. So (pair 1 (pair 2 3)), gives us (1 (2 3)). In this manner, pairs can create linked lists. To create a binary tree from two existing sub-trees, use (pair subtree1 subtree2)</p>
<p>The last ingredient in the pair system is the empty pair. This is usually represented by () and called nil. The empty pair represents the empty list.</p>
<p>Now let’s look at how to implement pair, head, and tail with lambda functions.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> pair</span>
    (<span class="kw">lambda</span> (x y)
        (<span class="kw">lambda</span> operator
            (operator x y))))</code></pre>
<p>So calling (pair 1 2) returns a function which can take an operator and apply it to 1 and 2. As with the boolean definitions, the reason for this will be clear in a moment.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> head</span>
    (<span class="kw">lambda</span> (p)
        (p true)))

(<span class="kw">define</span><span class="fu"> tail</span>
    (<span class="kw">lambda</span> (p)
        (p false)))</code></pre>
<p>So (head (pair x y)) expands to ((pair x y) true), which in turn expands to (true x y) which is x - the first item in the pair. Similarly (tail (pair x y)) expands to (false x y) - this returns y.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> nil</span>
    (<span class="kw">lambda</span> (x)
        true))</code></pre>
<p>So applying head to nil, (head nil), expands to (nil true) which is just true. Then with (tail nil), (nil false), which also expands to true.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> is-null</span>?
    (<span class="kw">lambda</span> (p)
        (p (<span class="kw">lambda</span> (x y) false))))</code></pre>
<p>The function is-null? returns whether a given list is empty. So (is-null? nil) becomes (nil (lambda (x y) false)) which just simplifies to true, because nil always returns true. When applied to a pair - (is-null? p) becomes (p (lambda (x y) false)), which in turn becomes ((lambda (x y) false) p1 p2), which is just false.</p>
<h4 id="numbers">Numbers</h4>
<p>Let’s go one step further by representing a basic numeral system. We’ll use the Church numeral system. In this, we’ll represent a number n by a lambda function that takes a function and applies it to its argument n times. Firstly, we define zero as</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> zero</span>
    (<span class="kw">lambda</span> f
        (<span class="kw">lambda</span> x x)))</code></pre>
<p>So this takes a function f and returns the identity function, i.e. it applies f zero times. To increment the successor function by</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> succ</span>
    (<span class="kw">lambda</span> n
        (<span class="kw">lambda</span> f
            (f ((n f) x)))))</code></pre>
<p>Let’s look at how this works with zero. (succ zero) expands to (lambda f (lambda x (f ((zero f) x)))), which in turn expands to (lambda f (lambda x (f x))).</p>
<p>For addition, we need to be able to take two numbers n and m and add them.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> add</span>
    (<span class="kw">lambda</span> (n m)
        (<span class="kw">lambda</span> f
            (<span class="kw">lambda</span> x
                ((m f) ((n f) x))))))</code></pre>
<p>So the result of calling (((add n m) f) x) is the same as (f (f … (f x))) applied n + m times.</p>
<p>To implement n*m, we use the following definition.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> mult</span>
    (<span class="kw">lambda</span> (n m)
        (<span class="kw">lambda</span> f
            (<span class="kw">lambda</span> x
                (n (m f))))))</code></pre>
<p>As (m f) is the same as applying f m times, (n (m f)) is the same as applying (m f) n times, i.e. f nm times.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> pow</span>
    (<span class="kw">lambda</span> b
        (<span class="kw">lambda</span> e
            (e b))))</code></pre>
<p>To compute the b^e, we use the pow function. ((pow b e) f) is the same as ((e b) f), which is the same as ((b (b … (b f))))</p>
<p>To determine whether a lambda number is zero, we use the following function.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> zero</span>?
    (<span class="kw">lambda</span> (n)
        ((n (<span class="kw">lambda</span> x false)) true)))</code></pre>
<p>So if n is zero, (zero? n) expands to ((zero (lambda x false)) true), becomes ((lambda x x) true) which is just true. If not, (zero? n) is ((n (lambda x false)) true), applies (lambda x false) to true at least once. As such, it will return false.</p>

<p>Tags: <a href="../tags/functional%20programming.html">functional programming</a>, <a href="../tags/scheme.html">scheme</a>.</p>
</div>
        <div id="footer">
            <p>This site generated using <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            Background by <a href="http://subtlepatterns.com/cubes">Sander Ottens</a>.</p>
        </div>
    </body>
    <script type="text/javascript">

</script>
</html>
