<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>wmasson - Nondeterministic Programming in Haskell</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/rss+xml" title="Blog" href="../rss.xml" />
    </head>
    <body>
        <h1><div id="title"><span class="rounded">wmasson</span></div></h1>
        <div id="navigation">
            <p><a href="../" class="rounded">Home</a></p>
            <p><a href="../posts.html" class="rounded">Posts</a></p>
	    <p><a href="../tags.html" class="rounded">Tags</a></p>
            <p><a href="../about.html" class="rounded">About</a></p>
	    <p><a href="../rss.xml" class="rounded">RSS</a></p>
        </div>
        <div id="content"><h2>Nondeterministic Programming in Haskell</h2>

<p>On <strong>January 26, 2013</strong></p>

<p>Warning, here be monads. Nondeterministic programming involves automatic searching for an answer given some constraints. <a href="http://mitpress.mit.edu/sicp/full-text/">Sicp</a> a book you should read if you haven’t already) introduces this concept with the <a href="http://mitpress.mit.edu/sicp/full-text/sicp/book/node89.html/">amb operator</a>. (amb e1 e2 … en) returns one of e1 … en ambiguously based on a set of rules. These rules are specified by using the require operator. (require <cond>) will stop amb from selecting values that prevent <cond> from being true. For example we can state</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(get-even)
    (<span class="kw">let</span> ((a (amb <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))
          (b (amb <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)))
        (require (<span class="kw">=</span> <span class="dv">8</span> (<span class="kw">+</span> a b)))
        (<span class="kw">list</span> a b)))</code></pre>
<p>This will return a and b such that they sum to 8 and are from certain sets. The problem with amb is that it requires either a complex evaluator or macro to get it to work. Haskell gives an alternative to this: the list monad. The list monad works almost identically to amb except that it will return all possible values instead of just one. So how does this work? The instance of list is as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> [] <span class="kw">where</span>
    <span class="fu">return</span> x <span class="fu">=</span> [x]
    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="fu">concat</span> (<span class="fu">map</span> f xs)
    <span class="fu">fail</span> _ <span class="fu">=</span> []</code></pre>
<p>When we return a value we just wrap it in a list. Binding works as follows xs &gt;&gt;= f will map all items of xs to f then concat them together. When we fail we just get an empty list. For example</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>] <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> <span class="fu">return</span> (x,y)</code></pre>
<p>will return all pairs (x,y) where x is from [1,2,3] and y is from [4,5,6]. The above example is ugly because we need to chain the different parts together with &gt;&gt;= and lambda declarations. Haskell provides do notation which chains functions together automatically.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">pairs <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
           y <span class="ot">&lt;-</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
           <span class="fu">return</span> (x,y)</code></pre>
<p>The function (guard <cond>) will pass the value unchanged to the next function if <cond> is true and fails (passes []) otherwise. If for example we want all pairs (x,y) such that x + y == 8 then we can add a guard to ensure this.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Control.Monad</span>

pairs <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
           y <span class="ot">&lt;-</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
           guard (x<span class="fu">+</span>y<span class="fu">==</span><span class="dv">8</span>)
           <span class="fu">return</span> (x,y)</code></pre>
<p>As you might have noticed this is exactly what we wanted to do with amb in the scheme example. guard works just like require did, we just state it and it eliminates all the values which don’t satisfy the stated conditions.</p>
<p>One cool thing to do with amb is solve logic problems. The Sicp chapter on non-deterministic values gives a number of these, let’s try translate some of these into do notation.</p>
<p>The first problem is simple and stated as follows in Sicp:</p>
<pre><code>Baker, Cooper, Fletcher, Miller, and Smith live on different floors 
of an apartment house that contains only five floors. 
Baker does not live on the top floor. 
Cooper does not live on the bottom floor. 
Fletcher does not live on either the top or the bottom floor. 
Miller lives on a higher floor than does Cooper. 
Smith does not live on a floor adjacent to Fletcher's. 
Fletcher does not live on a floor adjacent to Cooper's. 
Where does everyone live?</code></pre>
<p>To solve this we need to assign a floor number from 1 to 5 for each person while still satisfying all the conditions.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Data.List</span>
<span class="kw">import</span> <span class="dt">Control.Monad</span>

apart x y <span class="fu">=</span> <span class="fu">not</span> <span class="fu">$</span> <span class="fu">abs</span> (x <span class="fu">-</span> y) <span class="fu">==</span> <span class="dv">1</span>
distinct xs <span class="fu">=</span> nub xs <span class="fu">==</span> xs
assignFloors <span class="fu">=</span> <span class="kw">do</span> baker <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">4</span>]
                  cooper <span class="ot">&lt;-</span> [<span class="dv">2</span><span class="fu">..</span><span class="dv">5</span>]
                  fletcher <span class="ot">&lt;-</span> [<span class="dv">2</span><span class="fu">..</span><span class="dv">4</span>]
                  miller <span class="ot">&lt;-</span> [cooper<span class="dv">+1</span><span class="fu">..</span><span class="dv">5</span>]
                  smith <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]
                  <span class="kw">let</span> people <span class="fu">=</span> [baker,cooper,fletcher,miller,smith]
                  guard (distinct people)
                  guard (apart fletcher smith)
                  guard (apart fletcher cooper)
                  <span class="fu">return</span> people</code></pre>
<p>First we declare the possible values for each person. In the scheme version each number is selected from a range of 1 to 5 so that restrictions such as “Baker does not live on the top floor” need to be stated explicitly. I’ve baked these into the ranges of values. Then we only need to check Fletcher is apart from Smith and Cooper and that no two people are given the same floor which is done by checking the list of floor values is distinct. When we run this we will get a list of possible floor assignments that suit our conditions. One such assignment would be [3,2,4,5,1].</p>
<p>What’s most impressive about using the list monad for this is how elegant it is. The resulting code is almost identical to the Scheme solution using amb but without requiring extra leverage from interpreters or macros - it comes out naturally from the monad definition.</p>

<p>Tags: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/functional programming.html">functional programming</a>.</p>

<p>
 <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'wmasson'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</p>  
</div>
        <div id="footer">
            <p>This site generated using <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            Background by <a href="http://subtlepatterns.com/cubes">Sander Ottens</a>.</p>
        </div>
    </body>
    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37381827-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</html>
