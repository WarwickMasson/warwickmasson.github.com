<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>wmasson RSS feed.</title>
        <link>http://wmasson.com</link>
        <description><![CDATA[posts from wmasson.com.]]></description>
        <atom:link href="http://wmasson.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 06 Jan 2013 00:00:00 UT</lastBuildDate>
        <item>
    <title>Memoizing Functions in Python</title>
    <link>http://wmasson.com/posts/2013-01-06-memoizing-in-python.html</link>
    <description><![CDATA[<h2>Memoizing Functions in Python</h2>

<p>On <strong>January  6, 2013</strong></p>

<p>Memoization is the process of storing the return values of a function so that if the function is called again with the same arguments, we can return the stored value instead of recomputing it. Suppose we have a function f that is costly to run. We can memoize the return values by calling an intermediary</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> f(x):
	<span class="co"># some expensive computation</span>

seen = {} 

<span class="kw">def</span> memoize_f(x):
	<span class="kw">if</span> x in seen:
		<span class="kw">return</span> seen[x]
	<span class="kw">else</span>:
		seen[x] = f(x)
		<span class="kw">return</span> seen[x]</code></pre>
<p>If we want to call f, instead we call memoize_f and it will remember the values. This is inconvenient for two reasons. If we have another function, say g, that needs to be memoized we need another function memoize_g. Also, the seen list is globally accessable which is undesirable. Instead a class can be made to wrap the function and handle these things.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> memoizer:
	<span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,f):
		<span class="ot">self</span>.seen = {}
		<span class="ot">self</span>.f = f

	<span class="kw">def</span> lookup(<span class="ot">self</span>,x):
		<span class="kw">if</span> x in <span class="ot">self</span>.seen:
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]
		<span class="kw">else</span>:
			<span class="ot">self</span>.seen[x] = <span class="ot">self</span>.f(x)
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]

memoize_f = memoizer(f)</code></pre>
<p>This is a cleaner solution. When we want to get the value of f(x) we can call memoize_f.lookup(x). This is somewhat inelegent, ideally we should just have memoize_f be a function itself.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> memoize_func(f):
	m = memoizer(f)
	<span class="kw">return</span> m.lookup

memoize_f = memoize_func(f)</code></pre>
<p>This will return the part we want - the lookup function. This has the added bonus of obscuring the class itself: instead we just have the function that acts like f and we don’t have to worry about how the memoization works. There’s another little trick to make this even better.</p>
<pre><code>memoize = memoize_func(memoize_func)</code></pre>
<p>Here we have memoized the memoize_func so we always get back the same memoized version of a function. Suppose we want the memoized version of f but don’t have it in scope, then if we can just call memoize(f) and get the same memoized version we had before. For one final addition, let’s make it support multiple arguments:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> memoizer:	
	<span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,f):
		<span class="ot">self</span>.seen = {}
		<span class="ot">self</span>.f = f

	<span class="kw">def</span> lookup(<span class="ot">self</span>,*x):
		<span class="kw">if</span> x in <span class="ot">self</span>.seen:
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]
		<span class="kw">else</span>:
			<span class="ot">self</span>.seen[x] = <span class="ot">self</span>.f(*x)
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]</code></pre>
<p>This uses python’s *args feature to get a list of arguments.</p>

<p>Tags: <a href="/tags/python.html">python</a>, <a href="/tags/functional programming.html">functional programming</a>.</p>

<p>
 <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'wmasson'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</p>  
]]></description>
    <pubDate>Sun, 06 Jan 2013 00:00:00 UT</pubDate>
    <guid>http://wmasson.com/posts/2013-01-06-memoizing-in-python.html</guid>
</item>
<item>
    <title>Building a brainfuck to c compiler (in c)</title>
    <link>http://wmasson.com/posts/2013-01-11-brainfuck-to-c.html</link>
    <description><![CDATA[<h2>Building a brainfuck to c compiler (in c)</h2>

<p>On <strong>January 11, 2013</strong></p>

<p>Brainfuck is a simple turing machine language. It’s also a turing tarpit - a language that is turing complete but just about impossible to write useful programs in. It’s operation is incredibly simple - imagine you have an infinite length of tape where each square contains a number. You have a “head” that sits on one of the squares. The commands are as follows:</p>
<pre><code>&lt; : move the head left one square
&gt; : move the head right one square
+ : increment the head square
- : decrement the head square
. : print the head square
\ : get a character from standard input
[ : while the head square is not zero do
] : end [ block</code></pre>
<p>and that’s all. The awesome part about this simplicity is that each command can be mapped exactly to a piece of c code. We need some memory so create an array of some fixed size. We also need a number to represent the head.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> memory[size];
<span class="dt">int</span> p = size/<span class="dv">2</span>;</code></pre>
<p>Then the transformations are</p>
<pre class="sourceCode c"><code class="sourceCode c">&lt; : <span class="kw">if</span>(p&gt;<span class="dv">0</span>)p--;
&gt; : <span class="kw">if</span>(p&lt;size<span class="dv">-1</span>)p++;
+ : memory[p]++;
- : memory[p]--;
. : putchar(memory[p]);
\ : memory[p] = getchar();
[ : <span class="kw">while</span>(memory[p]!=<span class="dv">0</span>){
] : }</code></pre>
<p>We need to limit the head movements so it doesn’t go out of the memory. To compile a brainfuck file we just need to go through the characters and emit the right c code. The completed code is on <a href="https://github.com/WarwickMasson/brainfuck-to-c">github</a>. This version properly formats the c code by adding indents.</p>

<p>Tags: <a href="/tags/brainfuck.html">brainfuck</a>, <a href="/tags/c.html">c</a>.</p>

<p>
 <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'wmasson'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</p>  
]]></description>
    <pubDate>Fri, 11 Jan 2013 00:00:00 UT</pubDate>
    <guid>http://wmasson.com/posts/2013-01-11-brainfuck-to-c.html</guid>
</item>
<item>
    <title>Visualizing Markov Chains</title>
    <link>http://wmasson.com/posts/2013-01-17-visualizing-markov-chains.html</link>
    <description><![CDATA[<h2>Visualizing Markov Chains</h2>

<p>On <strong>January 17, 2013</strong></p>

<p>Markov chains are used for modelling processes that have a number of possible states and at each time step move from the current state to the next one based on some transition probabilities. The collection of transition probabilities is given in the form of a transition matrix. For example, suppose we have 2 weather states: rainy and sunny. Then if the transition probabilities are given by</p>
<pre><code>rainy to sunny: 70%
rainy to rainy: 30%
sunny to rainy: 5%
sunny to sunny: 95%</code></pre>
<p>So the transition matrix is then</p>
<pre><code>        sunny   rainy
sunny    0.95    0.05
rainy    0.7     0.3</code></pre>
<p>A markov chain also has a set of initial probabilities - how likely it is to start in a given state. For example the probabilities of starting a new season may be</p>
<pre><code>sunny 90%
rainy 10%</code></pre>
<p>It’s easy to imagine how this chains works - a large number of sunny days with occasional rainy days and rarer rainy periods. Imagining how larger markov chains operate can be difficult when we have for example 10 states and consequently a 10 by 10 transition matrix. One way is follow an instances of the chain as it moves from state to state. This gives us some idea, but it can still be hard to see exactly how the probabilities work. Rather, let’s follow a group of instances.</p>
<p>This animation simulates a large number of ants moving from nest to nest. When the ant arrives at a next nest, it moves to another nest based on a randomly generated transition matrix. I’ve biased the transition matrix so that it appears more uneven and added some noise to the speed of the ants so that they don’t just set off at the same time.</p>
<iframe style="border: 0px;" scrolling="no" width="500px" height="500px"
src = "../js/markov_chain.html"></iframe>

<p>Notice how certain paths are very well travelled and others only have intermittent ants. The number of ants of a path from nest A to nest B is not just dependent on probability of going from A to B but also how many ants are going to A in the first place. This allows us to see the general traffic flow in the chain.</p>

<p>Tags: <a href="/tags/d3.html">d3</a>, <a href="/tags/markov chains.html">markov chains</a>.</p>

<p>
 <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'wmasson'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</p>  
]]></description>
    <pubDate>Thu, 17 Jan 2013 00:00:00 UT</pubDate>
    <guid>http://wmasson.com/posts/2013-01-17-visualizing-markov-chains.html</guid>
</item>

    </channel> 
</rss>
