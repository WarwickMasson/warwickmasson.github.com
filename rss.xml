<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>wmasson RSS feed.</title>
        <link></link>
        <description><![CDATA[wmasson posts]]></description>
        <atom:link href="/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 06 Jan 2013 00:00:00 UT</lastBuildDate>
        <item>
    <title>Memoizing Functions in Python</title>
    <link>/posts/memoizing_in_python.html</link>
    <description><![CDATA[<h2>Memoizing Functions in Python</h2>

<p>On <strong>January  6, 2013</strong></p>

<p>Memoization is the process of storing the return values of a function so that if the function is called again with the same arguments, we can return the stored value instead of recomputing it. Suppose we have a function f that is costly to run. We can memoize the return values by calling an intermediary</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> f(x):
	<span class="co"># some expensive computation</span>

seen = {} 

<span class="kw">def</span> memoize_f(x):
	<span class="kw">if</span> x in seen:
		<span class="kw">return</span> seen[x]
	<span class="kw">else</span>:
		seen[x] = f(x)
		<span class="kw">return</span> seen[x]</code></pre>
<p>If we want to call f, instead we call memoize_f and it will remember the values. This is inconvenient for two reasons. If we have another function, say g, that needs to be memoized we need another function memoize_g. Also, the seen list is globally accessable which is undesirable. Instead a class can be made to wrap the function and handle these things.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> memoizer:
	<span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,f):
		<span class="ot">self</span>.seen = {}
		<span class="ot">self</span>.f = f

	<span class="kw">def</span> lookup(<span class="ot">self</span>,x):
		<span class="kw">if</span> x in <span class="ot">self</span>.seen:
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]
		<span class="kw">else</span>:
			<span class="ot">self</span>.seen[x] = <span class="ot">self</span>.f(x)
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]

memoize_f = memoizer(f)</code></pre>
<p>This is a cleaner solution. When we want to get the value of f(x) we can call memoize_f.lookup(x). This is somewhat inelegent, ideally we should just have memoize_f be a function itself.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> memoize_func(f):
	m = memoizer(f)
	<span class="kw">return</span> m.lookup

memoize_f = memoize_func(f)</code></pre>
<p>This will return the part we want - the lookup function. This has the added bonus of obscuring the class itself: instead we just have the function that acts like f and we don’t have to worry about how the memoization works. There’s another little trick to make this even better.</p>
<pre><code>memoize = memoize_func(memoize_func)</code></pre>
<p>Here we have memoized the memoize_func so we always get back the same memoized version of a function. Suppose we want the memoized version of f but don’t have it in scope, then if we can just call memoize(f) and get the same memoized version we had before. For one final addition, let’s make it support multiple arguments:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> memoizer:	
	<span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,f):
		<span class="ot">self</span>.seen = {}
		<span class="ot">self</span>.f = f

	<span class="kw">def</span> lookup(<span class="ot">self</span>,*x):
		<span class="kw">if</span> x in <span class="ot">self</span>.seen:
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]
		<span class="kw">else</span>:
			<span class="ot">self</span>.seen[x] = <span class="ot">self</span>.f(*x)
			<span class="kw">return</span> <span class="ot">self</span>.seen[x]</code></pre>
<p>This uses python’s *args feature to get a list of arguments.</p>

<p>
 <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'wmasson'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</p>  

<p>Tags: <a href="/tags/python.html">python</a>, <a href="/tags/functional programming.html">functional programming</a>.</p>

]]></description>
    <pubDate>Sun, 06 Jan 2013 00:00:00 UT</pubDate>
    <guid>/posts/memoizing_in_python.html</guid>
</item>

    </channel> 
</rss>
